{"pages":[],"posts":[{"title":"2018年快结束了，我已经25了","text":"我的未来式 2018年11月24日，周六 继周五，也就是昨天，感冒请假1天后，又到了“愉快”的周末。仿佛昨晚的开黑还不够尽兴，今天，周六考虑这个特殊的时间点，“本”就该放松休息，早上醒来躺在床上玩会手游，到了9点有点饿，于是不得已起床去买了早餐。回来也才9点多点，时间还早干嘛呢，这么多时间怎么“挥霍”呢？是打DOTA呢，还是去b站看电影或电视剧呢，that is a question……（不管干了啥，很快2小时过去了，到了饭点）下楼吃完午饭回来，已经1点了，时间又还早（为什么要加又呢）做啥呢，还是继续边打手游边看日剧吧…好开心……（一通吃喝玩乐，不知不觉快5点了） 转折点来了，老妈发来问候消息，聊着聊着，又到了我一直逃避的话题（回来考个公务员吧，去事业单位工作稳定）为什么老一辈的人就那么希望我们进事业单位呢？原来老姐最近又在考试准备进事业单位，貌似考得还不错，就差政审了……（又开始了绕不开的论点）老妈觉得对我不够严格，谁谁家孩子以前学习成绩不好的，现在都出人头地了总之我们两最后谁也没有说服谁，就这样不了了之了。 虽然我和老妈的争论结束了，却把想在周末逃避现实的我又拉回了现实，胡玩疯玩，无所事事的状态及时止住了。 关上灯，在黑漆漆的屋子（冬天天黑的特别早）里，一个人对着天花板思考着我的未来在哪里，对于考公务员我确实是怎么都提不起兴趣，但是这样每个周末都无所事事，昏昏沉沉，确实也不是我该有的状态，再次提醒自己 你的目前状态年龄：25工作：在一家小公司，拿着10k的收入在上海苟延残喘女朋友：无房子：无车子：无额外收入：无 经过一番思想斗争，得出结论，虽然还是不决定考公务员，但是还是要考点什么杜绝无所事事。要给自己找点事干，不能整天在屋里死宅或是出去吃狗粮。 1.还做程序员么?（A.做 B.不做） A =&gt; 继续前端这条路， 那么考证什么的到还是次要的，关键是平时的时间能否利用起来，多学习一点，基础打扎实一点，明年回南京好找一个更好的工作 B =&gt; 不做程序员，那么考研应该是个不错的选择，是自己和家人所希望的。既然明年回南京，那么考个南京高校的研究生吧。考哪个专业的呢，目前有想法的有2个 （B1.计算机 B2.经济） B1 =&gt; 考计算机优势：有考上的大学同学可以取经劣势：难度会不会有点大（如果是南大的，会不会不好考）出来以后继续从事计算机方面的工作 B2 =&gt; 经济类优势：有考过，多多少少对于内容有些印象劣势：如果还是考南大的经济类（还是难度的问题）出来转行，从事经济方面的工作 还未确定的话，先把英语和数学复习起来","link":"/2018/11/24/2018年快结束了，我已经25了“/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/21/hello-world/"},{"title":"你好，Hexo","text":"Markdown初体验很多语法想试一下，比如加粗，比如说斜体，再比如说删除线 引用列夫托尔斯泰的一句话 : “ 每个人都会有缺陷，就像被上帝咬过的苹果，有的人缺陷比较大，那是因为上帝特别喜欢他的芬芳。” 无序列表 列表1 列表2 列表3 有序列表 列表4 列表5 列表6 表格 姓名 技能 排行 白羊座:穆 星尘毁灭 1 金牛座:阿鲁迪巴 巨角轰击 2 双子座:撒加 地爆天星 3 巨蟹座:迪斯马斯克 黄泉颤抖 4 狮子座:艾欧里亚 闪电光速拳 5 处女座:沙加 如来涅槃 6 天秤座:童虎 庐山百龙霸 7 天蝎座:米罗 猩红毒针 8 射手座:艾俄洛斯 黄金箭 9 摩羯座:修罗 圣剑 10 水瓶座:卡妙 曙光女神之宽恕 11 双鱼座:阿布罗狄 食人鱼玫瑰 12 代码const a = 1() if (a &gt; 0){ b = 1 } else { c = 1 } ()","link":"/2018/11/22/你好，Hexo/"},{"title":"Echarts采坑之路","text":"这两天在Vue项目中使用Echarts组件进行画图，遇到了一些坑，也找到了解决办法，现在把记录下来，以免再次掉坑。如有不对的地方，还请大家给我留言指正。 tooltip的自定义所谓的tooltip就是 而官方的tooltip是它的生成方式是1234567891011121314151617181920option = { tooltip: { trigger: 'item', formatter: \"{a} &lt;br/&gt;{b}: {c} ({d}%)\" }, legend: { .................... }, series: [ { name:'访问来源', type:'pie', ..................... data:[ {value:335, name:'直接访问'}, ............. ] } ]} 其中tooltip属性下的formatter是决定其格式的重要环节，问题来了，这个a,b,c,d是什么鬼，它们是固定的么？让我们一起来看一下官方api可以看出可用的数据只有c也就是data =&gt; value，而d的比例还是根据这个自动生成的，如果想引入其他的数据的话就需要第二种回调函数的形式，其中第一个参数params是formatter需要的数据集，其格式是固定的所以只需要在传入原始数据项给data时，将所需要的相关数据一并传入，再通过属性调用即可。1234567891011121314for(let item in temp){ nameArr.push(item) let obj = {} obj.value = 1 obj.name = item obj.num = temp[item].num obj.fieldNum = temp[item].fieldNum dataArr.push(obj)}metadataInfo.setOption({ tooltip: { trigger: 'item', formatter: (params) =&gt; (\"图层数量:\"+params.data.num+\"&lt;br&gt;要素数量:\"+params.data.fieldNum) }, 最后就能得到我们想要的效果了 同一区域echarts之间切换不覆盖问题概述所谓不覆盖就是，我在同一个div中需要绘制几个不同的图，当点击按钮时在图之间切换，而图与图之间的数据不会相互影响。 例如初始加载第一张“按图层”的柱状图a(正常)点击“按年份”切换到折线图b(正常) 问题来了~~~再点击“按图层”时加载的柱状图a就不对劲了，出现了折线图b的影子 经过长时间的调查后终于在Echarts的api中发现了蛛丝马迹好家伙，原来setOption不止可以传入图表的配置项和数据，还有其他配置参数，这个notMerge默认居然是false(= =!还是双重否定真是吃多了撑的)你默认跟之前设置的option合并是要闹哪样。果断把setOption({},true)改回来，这样就OK了，再怎么切换也不会重叠了。","link":"/2018/11/27/Echarts采坑之路/"},{"title":"提炼es6-4","text":"一、数组的扩展1、扩展运算符(…)好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。…[1,2,3] =&gt; 1 2 3 作用主要用于函数调用123456789function push(array,...items){ array.push(...items)}function add(x,y){ return x + y}const numbers = [4,38]add(...numbers) // 42 替代函数的apply方法前情回顾apply方法，和call方法类似，只是apply可以传arguments，而call方法必须要把参数全部列举，所以apply使用更加频繁。它们的调用apply(obj,args)，call(obj,[params,…])。其中obj为要调用该方法的对象，通常为this123456//ES5Math.max.apply(null,[14,3,77])//ES6Math.max(...[14,3,77])//等同于Math.max(14,3,77) 应用1:数组复制数组是复合的数据类型，直接复制只是复制了指向了底层数据结构的指针12345678910111213141516//直接复制const arr1 = [1,2]const arr2 = arr1arr2[0] = 3arr1 // [3,2]//es5变通方法复制const arr1 = [2,3]const arr2 = arr1.concat() //用于连接两个或多个数组，返回一个新数组arr2[0] = 4arr1 // [2,3]//es6扩展运算符const a1 = [1,2]const a2 = [...a1]const [...a2] = a1 应用2:合并数组类似于数组复制，合并数组也是一样1234567891011121314//ES5的合并数组a1.concat(a2,a3)//ES6的合并数组[...a1,...a2,...a3]//不过这两种方法都是浅拷贝，在数组元素是对象时需注意const b1 = [{foo:1}]const b2 = [{bar:2}]const b3 = b1.concat(b2)const b4 = [...b1,...b2]b3[0] === b1[0]b4[0] === b1[0]//虽然b3,b4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。 应用3:与解构赋值结合将扩展运算符用于数组赋值12345678910111213141516//es5a = list[0],rest = list.slice(1)//es6[a,...rest] = listconst list = [1,2,3,4,5]a //1rest //[2,3,4,5]const list = []a //undefinedrest // []const list = [&quot;foo&quot;]a // &quot;foo&quot;rest // [] 注意:将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 2.Array.from()Array.from方法用于将两类对象转为真正的数组:类似数组的对象(array-like object)和可遍历(iterable)的对象(包括ES6新增的数据结构Set和Map)1234567891011let arrayLike = { &apos;0&apos;:&apos;a&apos;, &apos;1&apos;:&apos;b&apos;, &apos;2&apos;:&apos;c&apos;, length:3}//es5var arr1 = [].slice.call(arrayLike)//es6let arr2 = Array.from(arrayLike) 实际应用中，常见的类似数组的对象时DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。12345678910//NodeList对象let ps = document.querySelectorAll(&apos;p&apos;)Array.from(ps).filter(p =&gt; { return p.textContent.length &gt; 100})//arguments对象function foo() { var args = Array.from(arguments)} 而这里所谓的类数组对象，必须有length属性 3.Array.of()该方法用于将一组值转换为数组。这个方法主要用于弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。123Array() // []Array(3) // [,,,]Array(3,11,8) // [3,11,8] 只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组，参数个数只有一个时，实际上是指定数组的长度。 4.数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没有符合条件的成员，则返回undefined。且它的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组1[1,2,3,4,5,6].find((val,index,arr) =&gt; val &gt; 4 &amp;&amp; index &gt; 4) //6 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。且它的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组123[1,5,10,15].findIndex(function(val,index,arr) { return val &gt; 5}) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象注意之前的三个参数是回调函数的参数，也就是find,findIndex的第一个参数，而这里的第二个参数是用来绑定回调函数的this对象。1234567//完整的写法const arr = [1,2,3,4,5,6]function f(v){ return v &gt; this.age}let person = {name:&apos;John&apos;,age:4}arr.find(f,person) //5 5.数组实例的fill()fill方法使用给定值填充一个数组。该方法用于空数组的初始化非常方便，数组中已有的元素会全部抹去。fill方法还接受第二个和第三个参数，用于指定填充的起始位置和结束位置(不包括)12345[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,2) //[&apos;a&apos;,7,&apos;c&apos;]//如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象,换句话说当其中一个改变时，其他也会跟着改变let arr = new Array(3).fill({name:&apos;Jack&apos;})arr[0].name = &quot;Ben&quot; arr // [{name:&apos;Ben&apos;},{name:&apos;Ben&apos;},{name:&apos;Ben&apos;}] 6.数组实例的entries(),key()和values()三个方法都是用于遍历数组的，它们都返回一个遍历器对象，可以用for…of循环进行遍历，区别是keys()是对键名的遍历、values()是对键值的遍历、entries()是对键值对的遍历。123456789101112131415161718192021222324for(let index of [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].keys()) { console.log(index)} // 0// 1for(let ele of [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].values()) { console.log(ele)}// a// bfor(let [index,ele] of [&apos;a&apos;,&apos;b&apos;].entries()){ console.log(index,ele)}// 0 &quot;a&quot;// 1 &quot;b&quot;//还可以手动调用遍历器对象的next方法，进行遍历let letter = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]let entries = letter.entries()console.log(entries.next().value()) // [0,&apos;a&apos;]console.log(entries.next().value()) // [1,&apos;b&apos;]console.log(entries.next().value()) // [2,&apos;c&apos;] 7.数组实例的includes()表示某个数组是否包含给定的值，与字符串的includes方法类似，返回一个布尔值12345678[12,23].includes(2) // false[1,2,3,NaN].includes(NaN)//第二个参数表述搜索的起始位置[1,2,3].includes(2,2) // false// 区别去之前使用的indexOf，缺点是不够语义化，内部用严格相等运算符(===)进行判断，所以NaN会判断错误arr.indexOf(2) !== -1[NaN].indexOf(NaN) // -1[NaN].includes(NaN) // true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本123456const fn = (() =&gt; Array.prototype.includes ? (arr,val) =&gt; arr.includes(val) : (arr,val) =&gt; arr.some(el =&gt; el === val))()fn([&apos;foo&apos;,&apos;bar&apos;],&apos;baz&apos;) 8.数组实例的flat(),flatMap()flat用于拉平数组，传入的参数用于选择拉平几层，默认拉平1层，返回一个新数组flatMap传入回调函数，用于处理数组中的元素类似于map函数，再拉平数组 12345678910111213[1,2,[3,4,[5,6]]].flat()// [1,2,3,4,[5,6]][1,2,[3,4,[5,6]]].flat(2)// [1,2,3,4,5,6][1,2,,3,4].flat(Infinity)// 会跳过空位，而且Infinity不管多少层都会转成一维数组[1,2,3,4].flatMap((x) =&gt; x*2)// [2,4,6,8]此时的功能类似于map函数[1,2,3,4].flatMap((x) =&gt; [x,x*2])// [1,2,2,4,3,6,4,8]先map再flat","link":"/2018/12/04/提炼es6-4/"},{"title":"提炼ES6(1)","text":"一、ES6简介 ECMAScript6.0(ES6)是JavaScript的下一代标准，2015.6发布，ES6是一个泛指，JS的下一代标准，涵盖了ES2015，ES2016，ES2017等等 Babel转码器在项目中使用ES6可能需要了解Babel，一个广泛使用的ES6转码器，可以将ES6代码转为ES5，从而在现有环境执行。 配置文件.babelrc其配置文件 .babelrc就是使用Babel的第一步，该文件用来设置转码规则和插件1234{ &quot;presets&quot;:[], //转码规则 &quot;plugins&quot;:[] //插件} 命令行转码babel-cli123$ babel xxx.js //转码xxx.js$ babel xxx.js --out-file(-o) yyy.js //转码结果输出到yyy.js$ babel aaa --out-dir(-d) bbb //转码目录到bbb 但是该代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel，这样项目就产生了对环境的依赖，另一方面，这样做也无法支持不同项目使用不同版本的Babel 一个解决办法是将babel-cli安装在项目中，转码的时候执行npm run build babel-register使用时，必须首先加载babel-register12require(&quot;babel-register&quot;)require(&quot;./index.js&quot;) 但是babel-register只会对require命令加载的文件转码，而且是实时转码，所以只适合开发环境 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块123456var es6Code = &apos;let x = n =&gt; n + 1&apos;var es5Code = require(&apos;babel-core&apos;) .transform(es6Code,{ presets:[&apos;latest&apos;] }) .code; babel-polyfillBabel默认只转换新的JS句法，而不转换新的api，比如Interator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码，这个时候就必须使用babel-polyfill为当前环境提供一个垫片。 二、let和const先来盘es6的开胃菜let和const命令let命令类似于var，但是又区别于它，最大的特色就是它会划分领地，虽然它被限制在自己的一亩三分地中，看似力量被削弱了，但是在这一亩三分地中又完全是它说了算，外部的同名的全局变量也无法影响它。语法上这种恐怖的力量叫暂时性死区（temporal dead zone）TDZ123456789101112var tmp = 123if(true){ //TDZ开始 tmp = &apos;abc&apos; //ReferenceError console.log(tmp) //ReferenceError let tmp; //TDZ结束 console.log(tmp) //undefined tmp = 123; console.log(tmp) //123} 它的另外2个特色就是不存在变量提升和不允许重复声明1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 和123456789function func(arg) { let arg; // 报错}function func(arg) { { let arg; // 不报错 }} ES6的块级作用域其实这也是let带来的。ES5只有全局作用域和函数作用域，这样会带来2种不合理的场景1、内层变量可能会覆盖外层变量2、for(var i …..)循环变量泄露为全局变量 const声明一个只读的常量，一旦声明，常量的值就不能改变，且必须立即初始化同样，只在声明所在的块级作用域内有效同样，不可重复声明同样，不存在变量提升同样，存在暂时性死区 谈谈const的本质const其实保证的不是变量的值不可变，而是变量所指向的那个地址不可变，也就是该变量必须一直指向那个地址。这对于简单数据类型（如数值，字符串，布尔值）没啥影响，因为其值就保存在那个内存地址上，但是对于复合型数据（如对象），变量指向的只是一个指向实际数据的指针，该指针不可变，但是它的值确实可以改变的12345678const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-only 因此ES6在ES5的基础上又多了2种声明变量的方法let和const,除了原有的var和function，将来还有import和class命令一共6种变量声明方法","link":"/2018/11/28/提炼es6-1/"},{"title":"提炼es6-3","text":"一、数值的扩展1、二进制和八进制表示法前情回顾:es5中二进制的表示是0b(0B)，而八进制的表示是0o(0O)0,十六进制0x(0X)但是es6中明确规定了八进制要使用0o(不能使用0,两个看起来很像，虽然也不是很少用到)12Number(&apos;0b111&apos;) //7，字符串转换数值Number(&apos;0o10&apos;) //8，字符串转换数值 2、Number.isFinite()，Number.isNaN()，Number.isInteger()Number.isFinite()用来检查一个数值是否为有限的Number.isNaN()用来检查一个数值是否为NaN 同时改动parseInt()和parseFloat()，es6将它们全部移植到Number对象上，其他保持不变，其目的是逐步减少全局性方法，使得语言逐步模块化。Number.parseInt()Number.parseFloat() Number.isInteger()用来判断一个数值是否为整数(区别于浮点数) 3、新添Math功能Math.trunc方法用于去除一个数的小数部分，返回整数部分123456789Math.trunc(-4.9) //-4Math.trunc(&apos;123.456&apos;) //123Math.trunc(true) //1Math.trunc(null) //0Math.trunc(&apos;foo&apos;) //NaNMath.trunc = Math.trunc||function (x) { return x &lt; 0 ? Math.ceil(x) : Math.floor(x)} Math.sign方法用于判断一个数是正数，负数，0。对于非数值会先将其转换为数值。1234567891011121314Math.sign(5) // +1Math.sign(-5) // -1Math.sign(0) // 0Math.sign(NaN) // NaNMath.sign(true) // +1Math.sign(&apos;9&apos;) // +1Math.sign = Math.sign || function(x) { x = +x if(x === 0|| isNaN(x)){ return x } return x &gt; 0 ? 1 : -1} 4、指数运算符(**)2 ** 2 =&gt; 42 ** 3 ** 2 =&gt; 2 ** (3 ** 2) =&gt; 512特点是右结合 二、函数的扩展1、函数参数的默认值12345678910es5函数默认值function fn1(x,y){ y = y || &apos;world&apos; return x + y}es6函数默认值function fn2(x,y = &apos;world&apos;){ return x + y} 2、函数参数的默认值与解构赋值结合使用12345678910111213141516function foo({x,y = 5}){ console.log(x,y)}foo({x : 1 , y : 2})function fetch(url,{body = &apos;&apos;,method = &apos;GET&apos;,header = {}}){ console.log(method)}fetch(&apos;www.baidu.com&apos;,{}) //console.log(&apos;GET&apos;)fetch(&apos;www.baidu.com&apos;) //报错，这种情况下第二个对象参数不能省略function fetch(url,{...} = {}){ console.log(method)}fetch(&apos;www.qq.com&apos;) //可以，有默认值 参数默认值的位置如果是在末尾，那么可以省略，比如1234function f(x,y=1){ console.log(y)}f(2) 但是如果不是在末尾，那么这个参数是没法省略的123456function f1(x=1,y=&apos;asdf&apos;,z){ console.log(z)}f1(2,,89) //报错f1(,&apos;string&apos;,90) //报错f1(undefined,undefined,213) //213 函数的length属性指定默认值后，函数的length属性，将返回没有指定默认值的参数个数，rest参数也不再计入length属性，12(function (a,b,c){}).length // 3(function (a,b,c=3){}).length //2 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域会消失。这种语法行为在不设置参数默认值时，是不会出现的。关键在于设置默认值前有没有给被设置的默认值声明123456789101112let x = 1function f(x,y=x){ console.log(y)}f(2) //2let z = 2function f1(y=z){ let z = 3 console.log(y)}f() // 2 最后测试一下，搞懂这个，函数作用域这里理解就差不多了1234567var x = 1function f(x,y=function f2(){x = 2}){ var x = 3 y() console.log(x)}求f()和x rest参数注意：rest参数之后不能再有其他参数，否则会报错12345function push(array,...items){ items.forEach(function(item){ array.push(item) })} 3、箭头函数（重点）单语句函数 var f = v =&gt; v等同于 var f = function (v){ return v} var f = () =&gt; 5var f = (num1,num2) =&gt; num1 + num2 如果箭头函数的代码块多于一条语句，就使用大括号将它们括起来，并且使用return语句返回1234var f = () =&gt; { let i = 1 return i} 箭头函数的一个用处是简化回调函数123456//普通回调[1,2,3].map(function () { return x*x})//箭头函数[1,2,3].map(x =&gt; x*x) 注意点：（1）函数体内的this对象就是使用时所在的对象，而不是定义时所在的对象12345678910function foo() { setTimeout(() =&gt; { console.log(&apos;id:&apos;,this.id) },1000)}var id = 21foo.call({id:42}) // 42foo() // 21 我的理解是foo.call(obj),相当于obj.foo(),而根据箭头函数的原则，this指向使用时所在的对象，所以this指向obj。而foo(),相当于window.foo()，this指向window 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。12345678910var handler = { id:&apos;123456&apos;, init:function() { document.addEventListener(&apos;click&apos;, event =&gt; this.doSomething(event.type),false) }, doSomething:function(type) { console.log(this.id) }} init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，this.doSomething会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。从下面例子就可以看出。1234567891011121314//ES6function foo() { setTimeout(() =&gt; { console.log(&apos;id&apos;,this.id) },1000)}//ES5function foo() { var _this = this setTimeout(function () { console.log(&apos;id&apos;,_this.id) },1000)} 不仅是this，arguments、super、new。target在箭头函数中也是不存在的，指向外层函数的对应变量。 不适用场合虽然箭头函数写法简介，但是由于它使得this从“动态”变成“静态”，也有不适合的场合 第一个是定义函数的方法123456const cat = { lives:9, jump: () =&gt; { this.lives-- }} 如果是普通函数，该方法内部的this指向cat，但是箭头函数使得this指向全局对象 第二个是需要动态this的时候1234var btn = document.getElementById(&apos;press&apos;)btn.addEventListener(&apos;click&apos;,() =&gt; { this.classList.toggle(&apos;on&apos;)}) 如果是普通函数，this就会动态指向被点击的按钮对象，但是箭头函数this指向全局对象","link":"/2018/12/03/提炼es6-3/"},{"title":"提炼es6-2","text":"一、变量的解构赋值1、数组解构赋值12345let [a,b,c] = [1,2,3]let [d,[[e],f]] = [4,[[5],6]]let [g,,h] = [7,,8]let [head,...tail] = [9,10,11,12]let [x,y,...z] = [13] 不管怎么样，遵循一个萝卜一个坑的原则就可以了，专业名词叫”模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 默认值数组结构赋值允许指定默认值，但是只有当右边的值等于undefined时，默认值才会生效123let [a = 1] = [2]a // 2let [b,c = 3] = [4,undefined] //b = 4,c = 3 2、对象解构赋值对象解构和数组解构一个重要的不同点就是，数组解构是根据顺序进行赋值，对象解构是根据属性名，是把覆盖变量属性后边的值12345let obj = {foo:&apos;aaa&apos;,bar:&apos;bbb&apos;}let {baz:b,foo:f} = objvar {x:y=3} = {x:5}y //5 也可以指定默认值 3、字符串的解构赋值1234const [a,b,c...] = &quot;hello&quot;let {length:len} = &quot;hello&quot;len //5 4、数值和布尔值的解构赋值12345let {toString:s} = 123s === Number.prototype.toString //truelet {toString:s} = trues === Boolean.prototype.toString //true 5、用途（1）交换变量的值123let x = 1let y = 2[x,y] = [y,x] （2）从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。1234567891011//返回一个数组function example() { return [1,2,3]}let [a,b,c] = example()//返回一个对象function obj() { return {foo:12,bar:300}}let {foo,bar} = obj() //foo 12,bar 300 （3）函数参数的定义123456//参数是一组有次序的值function f([x,y,z]){...}f([1,2,3])//参数是一组无次序的值function fn({a,b,c}){...}fn({c:3,a:2,b:1}) （4）提取JSON数据123456789let jsonData = { id:42, status:&quot;OK&quot;, data:[867,5309]}let {id,status,data:number} = jsonDataconsole.log(data) //data is not definedconsole.log(id,status,number) //42,&quot;OK&quot;,[867,5309] 二、字符串的扩展1、includes(),startsWith(),endsWith()3个方法都支持第二个参数，表示开始搜索的位置1234let s = &apos;Hello world&apos;s.startsWith(&apos;world&apos;,6) //从6开始到结束s.endsWith(&apos;Hello&apos;,5) //前5个字符s.includes(&apos;Hello&apos;,6) //从6开始到结束 2、repeat(),padStart(),padEnd()返回一个新字符串，&gt;=0小数向下取整，负数或Infinity报错，字符串会自动转换为数字‘na’.repeat(‘3’) 头部补全‘x’.padStart(5,’ab’)常用于数字的前补零‘1’.padStart(5,’0’)或’09-12’.padStart(10,’YYYY-MM-DD’) 3、模板字符串感受一下 传统JS语言的输出模板 模板字符串的输出模板 123456$(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt;&apos; + &apos;item in your basket,&apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos;) &lt;/td&gt; &lt;td&gt; 12345$(&apos;#result&apos;).append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); &lt;/td&gt; &lt;/tr&gt; 所有模板字符串的空格和换行都是被保留的，并使用${}嵌入变量。不仅如此，大括号内部还可以放入任意的JS表达式，可以进行运算，以及引用对象属性，甚至还可以调用函数123456let x = 1;let y = 2;`1 + 2 = ${x + y}`let obj = {x:1,y:2};`obj是${obj.x + obj.y}` 4、标签模板将字符串模板直接跟在函数后，可以起到调用的效果，但是调用方式略有不同，它会将模板字符串先处理成多个参数，再调用函数。1234567function tag(stringArr,value1,value2){...}let a = 5let b = 6tag`Hello ${a+b} world ${a*b}`tag([&apos;Hello &apos;,&apos; world &apos;,&apos;&apos;],15,50)","link":"/2018/11/29/提炼es6-2/"},{"title":"浅谈Vue路由","text":"关于vue-router，官方文档推荐大多数单页面应用都可以使用。 单页面应用和多页面应用的区别通过比较可以看出单页面具有多方面的优势，这也正使它逐渐成为Web应用开发的潮流，其中路由的开发也显得尤为突出。 单页面应用(SinglePage Web Application,SPA)多页面应用(MultiPage Application,MPA)组成一个外壳页面和多个页面片段组成多个完整页面构成资源共用(css,js)共用，只需在外壳部分加载不共用，每个页面按需加载刷新方式页面局部刷新或更改整页刷新url模式a.com/#/pageonea.com/#/pagetwoa.com/pageone.htmla.com/pagetwo.html用户体验页面片段间的切换快，用户体验良好页面切换加载缓慢，流畅度不够，用户体验比较差转场动画容易实现无法实现数据传递容易依赖url传参，或者cookie、localStorage等搜索引擎优化(SEO)需要单独方案，实现较为困难，不利于SEO检索，可利用服务器端渲染(SSR)优化实现方法简易试用范围高要求的体验度，追求界面流畅的应用适用于追求高度支持搜索引擎的应用开发成本较高，常需借助专业的框架较低，但页面重复代码多维护成本相对容易相对复杂 基本路由我们熟悉的排头导航结构就可以使用基本路由12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 动态路由匹配很多时候我们需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，将不同的用户使用同一个User组件，我们可以在vue-router的路由路径中使用”动态路径参数”来达到这个效果。123456789101112131415161718192021222324252627282930313233//router.jsexport default new Router({ routes: [{ path: &quot;/&quot;, redirect: &quot;/home&quot; },{ path: &quot;/home&quot;, name: &apos;Home&apos;, component: Layout, redirect: &quot;/home/homepage&quot;, children: [{ path: &quot;directory/:id/:name&quot;, name: &quot;Directory&quot;, component: () =&gt;import (/* webpackChunkName: &quot;directory&quot; */&apos;@/components/directory&apos;)//目录 }] }]})//xxx.vueeditAllData(data) { if (typeName === &quot;目录&quot;) { this.$router.push({ name: &quot;Directory&quot;, params: { id: data.id, //父级id name: (data.tid?data.label:&quot;目录&quot;) }, query: { type: (data.tid?&quot;edit&quot;:&quot;add&quot;), typeid: data.typeId } }) }} 这样/directory/id/name都会指向Directory组件，其中通过params和query传递的参数可以使用this.$route.params和this.$route.query获得。 注意:当使用路由参数时，例如从/directory/123/dist1导航到/directory/456/dist2，原来的组件实例会被复用，不会重新加载，也就是说组件的生命周期钩子函数不会再被调用。1234567891011121314151617//Directory组件created() { loadData() {}}//不会被调用//如果需要特殊处理的话，需要动态监听$route对象watch:{ $route(to,from){ //对路由变化作出响应 }}//或者使用beforeRouteUpdate导航守卫beforeRouteUpdate(to,from,next){ // 在当前路由改变，但是该组件被复用时调用 // 比如，对于一个带有动态参数的路径/foo/:id，在/foo/1和/foo/2之间跳转的时候 // 由于会渲染同样的Foo组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用 // 可以访问组件实例&apos;this&apos;} 嵌套路由实际开发中时常会遇到多层嵌套的组件组合，同样地，URL中各段动态路径也按某种结构对应嵌套的各层组件，12345678/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 顶层的是app.vue主组件嵌套user.vue组件，其中user组件的路由是动态路由匹配。这里的\\&lt;router-view>是最顶层的出口，渲染最高级路由匹配到的组件。123456789&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;const User = { template: &apos;&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;&apos;}const router = new VueRouter({ routes: [ { path: &apos;/user/:id&apos;, component: User } ]}) 同样地，一个被渲染组件同样可以包含自己的嵌套。比如在User组件的模板添加一个12345678910111213141516171819202122232425262728const User = { template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User {{ $route.params.id }}&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `}//要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置const router = new VueRouter({ routes: [ { path: &apos;/user/:id&apos;, component: User, children: [ { // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile }, { // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts } ] } ]})","link":"/2018/12/11/浅谈Vue路由/"}],"tags":[],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Echarts","slug":"Echarts","link":"/categories/Echarts/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}